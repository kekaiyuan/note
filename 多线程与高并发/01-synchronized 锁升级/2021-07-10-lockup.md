---
layout: post
title: Java 多线程与高并发之—— synchronized 锁升级
categories: Java
description: some word here
keywords: Java
mermaid: true
---

Java 多线程与高并发之—— synchronized 锁升级

# 序言
以前 synchronized 是直接使用**重量级锁**的（通过操作系统调度线程，需要进行**状态切换**）。

后来人们发现这种方式的开销太大了，经过研究，提出了以下的锁升级模式：

```mermaid
graph LR;
A[无锁状态] --> B[偏向锁]
B --> C["轻量级锁（自旋锁）"]
C --> D[重量级锁]
```

# 无锁状态
无锁状态很简单，就是资源没有被上锁。

# 偏向锁
HotSpot 的作者在经过大量的研究发现，大多数时候是不存在锁竞争的，常常是**一个线程多次获得同一个锁**。<br>
也就是说，在一段时间，某个资源往往只有**一个**线程在使用。<br>
此时如果每一次访问都要上锁，会大大影响程序执行的效率。

所以提出了偏向锁。

某资源如果**第一次**被某线程访问，那么该资源会**偏向**这个线程，它会在对象头中记录该线程的 **ID** 。<br>
当该线程再次访问时，经过对比，发现线程 ID **一致**，那么就可以**直接访问**，**省略**加锁解锁操作。

现假设某偏向锁被线程 1 持有，当线程 2 尝试获取锁时，发现是个偏向锁，它会检查线程 1 的**状态**：
- 线程 1 **存活**，先将线程 1 **暂停**，将锁**升级**为轻量级锁，然后线程 1 **继续**执行。
- 线程 1 **不存在**，则线程 2 **直接持有**该偏向锁，**不进行锁升级**。

# 轻量级锁
轻量级锁又称**自旋锁**，由偏向锁升级而来。

现在锁已经被线程 1 持有，然后线程 2 也要竞争锁。<br>
线程 2 会进行以下等待：
```java
while(没有获得锁){
	//什么都不做
}
```
这是一个**循环**，什么拿到锁，什么时候结束该循环，继续执行。

于是有人形象地称呼这个循环操作为**自旋**。

# 重量级锁
重量级锁需要将线程在**用户态**和**内核态**之间来回切换，这个切换过程是需要时间的。

于是轻量级锁的**本质**是用**短时间**的**忙等**（使用了 CPU ，但是没有执行任何**有效**的任务——**自旋**）换取线程的状态切换的开销。

所以当轻量级锁的开销**大于**重量级锁的开销时，进行锁升级。

一般轻量级锁在自旋 **10** 次后会升级为重量级锁。<br>
切换到内核态，进入阻塞队列，等待操作系统的调度。

# 锁的细化与粗化
## 锁细化
我们在编程的时候，都会尽量把同步代码块写的很小。<br>
因为同步代码块的执行是互斥的，同一时刻最多只能有一个线程执行同步代码块，其他线程只能等着锁被释放。

## 锁粗化
如果我们的程序是这样的：
```java
对 object 1 加锁
操作1
解锁
...
对 object 1 加锁
操作2
解锁
...
对 object 1 加锁
操作3
解锁
```

也就是说对**同一对象**反复的加锁解锁，那么实际上这样的写法是更好的。
```java
对 object 1 加锁
操作1
...
操作2
...
操作3
解锁
```

这就是**锁粗化**。

如果 JVM 虚拟机检测到对同一对象一连串的加锁解锁操作，就会**自动**进行锁粗化的操作。

# 三种锁的区别

| 锁       | 优点                                                         | 缺点                                                 | 适用场景                                             |
| :------- | :------------------------------------------------------------ | :---------------------------------------------------- | :---------------------------------------------------- |
| 偏向锁   | 不需要加锁解锁，只需要对比 ID<br />和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，<br />会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景                     |
| 轻量级锁 | 竞争的线程不会阻塞<br />提高了程序的响应速度                 | 自旋会消耗CPU<br>  | 追求响应速度<br />同步块执行速度非常快<br />线程数少 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                        | 线程阻塞，响应时间缓慢                               | 追求吞吐量<br />同步块执行速度较慢<br />线程数多     |

# 注意
为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了。

偏向锁升级为轻量级锁也不能再降级为偏向锁。

一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。