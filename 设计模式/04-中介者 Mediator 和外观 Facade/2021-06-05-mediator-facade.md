---
layout: post
title: 设计模式之——中介者 Mediator 和外观 Facade
categories: DesignPatterns
description: 设计模式之——中介者模式 Mediator 和外观模式 Facade
keywords: Java，设计模式
---

设计模式之——中介者 Mediator 和外观 Facade

# 中介者模式

假设现在你有五个模块，这五个模块之间互有联系。

 ![image](/images/posts/designpatterns/mediator-facade/mediator-01.png)

联系有点复杂，但是好像还可以接受。

但是如果模块数量继续增加呢？<br>
联系网会迅速膨胀，变得复杂，臃肿，并且难以维护。

所以我们需要一个“中介者”，帮我们调停模块之间的联系。

 ![image](/images/posts/designpatterns/mediator-facade/mediator-02.png)

消息队列也是提现了这样的思想。

模块们把消息送给消息队列，然后从消息队列拿自己需要的消息。

我的消息应该送给谁？我应该从谁哪里拿消息？这些问题就不需要考虑了，程序耦合度会大大降低。

所有的消息都放在队列中，想要什么消息自己取，而不是等着谁来发给你你所需要的消息。

消息队列就类似于菜鸟驿站，快递员只负责把快递送到驿站，不负责送到每个人手里。谁有快递自己去驿站取。


## 概念

> 以下内容引用自 [菜鸟教程](https://www.runoob.com/design-pattern/mediator-pattern.html)
> 
> - 意图
> 	- 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
> 
> - 主要解决
> 	- 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。
> 
> - 何时使用
> 	- 多个类相互耦合，形成了**网状**结构。
> 
> - 如何解决
> 	- 将上述网状结构分离为**星型**结构。
> 
> - 关键代码
> 	- 对象 Colleague 之间的**通信封装**到一个类中单独处理。
> 
> - 应用实例
> 	- 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。
> 	- 机场调度系统。 
> 	- **MVC** 框架，其中C（控制器）就是 M（模型）和 V（视图）的调停者。
> 
> - 优点
> 	- 降低了类的复杂度，将一对多转化成了一对一。 
> 	- 各个类之间的**解耦**。 
> 	- 符合迪米特原则。
> 		- 迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。英文简写为: LOD。
> 
> - 缺点
> 	- 中介者会庞大，变得复杂难以维护。
> 
> - 使用场景：
> 	- 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。
> 	- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。
> 
> - 注意事项
> 	- 不应当在职责混乱的时候使用。

# 外观模式

外观模式和中介者模式非常像，其核心思想都是把程序解耦，把各个模块之间的复杂联系集中到一个单独的类中。

区别在于一个是外部联系，一个是内部联系。

比如说现在有一家公司，人员和业务非常多。

前台就是外观模式，他负责帮助外来人员和公司之间的联系。

而公司内部负责协调工作的小组就是中介者模式，他负责协调公司内部各个部门之间的联系。

又比如 MVC 模式，对于 Model 来说，Controller 是中介者。<br>
因为 Model 通过 Controller 和其它 Model 产生联系，他们是一个群体，Controller 是**内部**的协调器，是**中介者模式**。

对于 View 来说，Controller 是外观模式。<br>
因为 View 通过 Controller 和 Model 群体产生联系，这是两个群体的交互。
所以是一个**外部**的协调器，是**外观模式**。


加入外观模式之前：

![image](/images/posts/designpatterns/mediator-facade/facade-01.png)

加入外观模式之后：

![image](/images/posts/designpatterns/mediator-facade/facade-02.png)

## 概念
外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。

这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

> 以下内容引用自 [菜鸟教程](https://www.runoob.com/design-pattern/facade-pattern.html)
> 
> - 意图
> 	- 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
> 
> - 主要解决
> 	- 降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
> 
> - 何时使用
> 	- 客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。
> 	- 定义系统的入口。
> 
> - 如何解决
> 	- 客户端不与系统耦合，外观类与系统耦合。
> 
> - 关键代码
> 	- 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
> 
> - 应用实例
> 	- 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。
> 	- JAVA 的三层开发模式。
> 
> - 优点
> 	- 减少系统相互依赖。
> 	- 提高灵活性。 
> 	- 提高了安全性。
> 
> - 缺点
> 	- 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。
> 		- 开闭原则
> 			- 对拓展开放，对修改关闭。
> 			- 可以加新功能，但是不要修改原有功能的代码。
> 
> - 使用场景
> 	- 为复杂的模块或子系统提供外界访问的模块。
> 	- 子系统相对独立。 
> 	- 预防低水平人员带来的风险。
> 
> - 注意事项
> 	- 在层次化结构中，可以使用外观模式定义系统中每一层的入口。

# 总结
中介者模式和外观模式并不是类似于单例模式有特定模板的模式，它们体现的是**封装**的思想。

调用关系是编程中也需要特别注意的一点，当调用关系比较复杂时，一定要设计一个模块，专门用于封装不同模块之间的调用。

当程序过于复杂时，甚至可以采用多重中介者模式。

每个中介者协调一组模块，最终所有的中介者再由一个中介者协调。

例如快递网络。

小镇的运输中心聚集附近村子的快递。<br>
城市的运输中心聚集附近小镇的。<br>
省会的运输中心聚集该省的快递。<br>
在这之上还有按地域划分的运输中心：比如华东运输中心、华南运输中心……<br>
通过这多重网络才真正覆盖全国。