---
layout: post
title: MySQL 之——索引
categories: MySQL
description: MySQL 之——索引
keywords: MySQL
mermaid: true
---

索引是任何数据库中都十分**重要**的一个技术点。

# 序言

- 索引是帮助 MySQL 高效获取数据的数据结构。
- 索引存储在文件系统中，是持久化的数据，在使用时才加载到内存加快速度。
- 索引的文件存储形式与存储引擎有关。

索引是放在磁盘的，是持久化的数据。<br>
只是在使用的时候为了加快速度加载到内存。

# 数据结构
从数据结构的层面上来说，以下四种数据结构都能作为索引文件的结构：
- hash
- 二叉树
- B 树
- B+ 树

但是实际中，大多数索引都是使用 **B+ 树**的结构。

这是因为其他数据结构都存在着着或多或少的问题。

## Hash 表
- hash 表适用于**等值查询**，而业务中更多的是**范围查询**。
- hash 表在使用的时候需要把全部的数据加载到内存，比较**耗费内存空间**。

## 二叉树
### 普通二叉树
普通的二叉树适用于二分查找，但是存在左右子树**不平衡**的情况。<br>
严重时二叉树会变成类似于**链表**的结构（只有左子树没有右子树或者只有右子树没有左子树）。<br>
![image](/images/posts/database/mysql/index/binary-tree2.png)


### AVL 树
AVL树是一颗严格意义上的平衡树，最高子树跟最低子树高度之差不能超过1。

但是为了维护 AVL 树的平衡，在进行元素插入时经常会需要进行 1 到 N 次的**旋转**，严重影响插入的性能。

![image](/images/posts/database/mysql/index/avl-tree2.png)

### 红黑树
红黑树是基于AVL树的一个升级，损失了部分查询的性能，来提升插入的性能。<br>
在红黑树中最低子树跟最高子树高度之差不超过 **2 倍**即可。<br>
在插入的时候，不需要进行 N 多次的旋转操作。<br>
而且还加入了**变色**的特性，来满足插入和查询性能的平衡。

![image](/images/posts/database/mysql/index/red-black-tree2.png)

### 总结
二叉树及其 N 多的变种都**不能**支撑索引。<br>
原因是树的深度无法控制或者插入数据的性能比较低。

## B树
B树特点：
1. 所有键值分布在整颗树中。
2. 搜索有可能在非叶子结点结束，在关键字全集内做一次查找，性能逼近二分查找。
3. 每个节点最多拥有 m 个子树。
4. 根节点至少有 2 个子树。
5. 分支节点至少拥有 m/2 颗子树（除根节点和叶子节点外都是分支节点）。
6. 所有叶子节点都在同一层，每个节点最多可以有 m-1 个key，并且以升序排列。

![image](/images/posts/database/mysql/index/b-tree3.png)

实例图说明：<br>
每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。<br>
两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。<br>
以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。 <br>

查找关键字 28 过程：
1. 根据根节点找到磁盘块 1，读入内存。【第 1 次磁盘 I/O 操作】
2. 比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。
3. 根据 P2 指针找到磁盘块 3，读入内存。【第 2 次磁盘 I/O 操作】
4. 比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。
5. 根据 P2 指针找到磁盘块 8，读入内存。【第 3 次磁盘 I/O 操作】
6. 在磁盘块 8 中的关键字列表中找到关键字 28。 


----------


**缺点：**<br>
每个节点不仅存储 key 值，还存储数据 data ，会造成以下的情况：
```mermaid
graph LR;
A[data 越大] --> B[key 数量越少]
B --> C[树越深]
C --> D[索引性能越差]
```

B 树的**节点的索引数量**和**总索引数量**是**指数级**的关系：<br>
假设每个节点能够存储 x-1 个键值和 x 个指向子节点的指针。
- 第一层：x-1 个键值，x 个指针
- 第二层：x(x-1) 个键值，x·x 个指针
- 第三层：x·x·(x-1) 个键值，x·x·x 个指针
...

对于键值而言，数据实在是太大了，会严重减少键值的数量，加大树深。<br>
所以提出了 B+ 树：**非叶子节点不存储数据**。

## B+ 树
B+Tree是在BTree的基础之上做的一种优化，变化如下：
1. B+Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了**降低**树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越**快**。
2. 非叶子节点存储key，叶子节点存储key和数据。
3. 叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高。

![image](/images/posts/database/mysql/index/b-plus-tree.png)

**注意：**<br>
在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种**链式环结构**。<br>
因此可以对 B+Tree 进行两种查找运算：
1. 一种是对于主键的**范围查找**和**分页查找**。
2. 另一种是从根节点开始，进行**随机查找**。


----------


B+ 树的树深**非常低**：<br>
假设磁盘块大小为 4k ，寻址空间为 32 位，则指针大小为 4 字节，键值暂定为 int 类型，同样是 4 字节。
- 第一层：500 个键值，500 个指针
- 第二层：25000 个键值，25000 个指针
- 第三层：**1250 万**个键值，**1250 万**个键值
- 第四层：62.5 亿个键值，62.5 亿个键值

一般的数据库最多到**三层**，如果超过了 1250 万条数据，那么一定是要分库分表的，不会存在一个数据库里。<br>
这个树深，是任何二叉树，甚至 B 树都比不了的。

### 聚簇索引
在 **InnoDB** 中，**数据和索引是存储在一起的**，这种方式称为**聚簇索引**。

聚簇索引就是按照每张表的**主键**构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为**数据页**。<br>
这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。
![image](/images/posts/database/mysql/index/innodb.jpg)

InnoDB 通过主键聚集数据。<br>
如果没有定义主键，InnoDB 会选择非空的唯一索引代替。<br>
如果没有这样的索引，InnoDB 会使用 rowID （行号）作为隐式的主键。

rowID 是一个 **6 字节**的字段，随着插入新行而单调增加。<br>
因此，按行 ID 排序的行在**物理**上是按插入顺序排列的。

```mermaid
graph LR;
A[使用主键] --没有主键--> B[使用唯一键]
B --没有唯一键--> C[使用 rowID]
```


----------


#### 回表
一般来说，除了搜索引擎帮我们自动创建的主键索引外。<br>
我们可以自定义某些列实现**辅助索引**。

在 InnoDB 中，辅助索引的叶子节点存储的不是行记录数据，而是**主键值**。<br>
![image](/images/posts/database/mysql/index/innodb2.png)

使用辅助索引查询数据的流程是这样的：
1. 查询辅助索引树获取主键。
2. 在主键索引中获取数据。

也就是说，要查**两棵索引树**。

使用辅助索引总是要进行**二次查找**，所以有时也将辅助索引称为**二级索引**。


----------


#### 索引覆盖
假设现在有一张表
```
Table test{
	id int(11) primary key,
	name varchar(20),
	sex varchar(10),
	job varchar(50)
}
```
并且有主键索引 (id) ，和普通索引 (name ,sex)

当执行`select sex from Test where name = 'XXX';`是不需要回表的。<br>
因为 sex 本身就在索引中，不需要到主键索引中去寻找。

但如果执行`select * from Test where name = 'XXX';`就需要回表。<br>
因为 job 不在索引中，需要到主键索引中去寻找。

也就是说，在使用聚簇索引的普通索引时，能不查找索引之外的字段，就不要查找。<br>
因为这样可以只执行**一次查询**。<br>
而回表是**两次查询**。


----------


#### 索引下推
现在有这样一张表 test

| id | name | age | sex |
| :--: | :--: | :--: | :--: |
| 1 | zhangsan | 10 | man |
| 2 | zhangsan | 20 | man |
| 3 | zhangsan | 30 | man |
| 4 | zhangsan | 40 | man |

建立了联合索引 (name ,age)

现在要执行语句 `select * from test where name = 'zhangsan' and age = 10;`

在 **MySQL 5.6** 之前，是没有索引下推的，也就是说尽管这是一颗联合索引树，但是在 InnoDB 的眼里，age 字段是被**忽略**的

 InnoDB "眼中" 的索引树

| id | name | age | 
| :--: | :--: | :--: |
| 1 | zhangsan | ~~10~~ |
| 2 | zhangsan | ~~20~~ |
| 3 | zhangsan | ~~30~~ |
| 4 | zhangsan | ~~40~~ |

此时会先从 (name ,age) 索引树中找出 `name = 'zhangsan'` 的 **4** 个 id 值，<br>
然后再去 (id) 索引树中检索`age = 10` 的数据。

但在 **MySQL 5.6** 之后，有了索引下推，此时进行搜索时，搜索引擎不会忽略 age 字段

 InnoDB "眼中" 的索引树

| id | name | age |
| :--: | :--: | :--: |
| 1 | zhangsan | 10 |
| 2 | zhangsan | 20 |
| 3 | zhangsan | 30 |
| 4 | zhangsan | 40 |

此时 (name ,age) 索引树会返回符合`name = 'zhangsan' and age = 10`的 **1** 个 id 值，<br>
然后在 (id) 索引树中直接返回数据。

**索引下推就是在第一次索引时就进行条件匹配，减少第二次索引的数量。**

### 非聚簇索引
在 **Myisam** 中，B+ 树的叶子节点存储的是**行数据记录的地址**。<br>
**这种数据和索引分开存放的方式**，称之为非聚簇索引。<br>
![image](/images/posts/database/mysql/index/myisam.jpg)


----------


非聚簇索引的**辅助索引**的叶子节点依然是存储行数据记录的**地址**。
![image](/images/posts/database/mysql/index/myisam2.png)

也就是说，在非聚簇索引中，主键索引和辅助索引除了键值的不同，返回值是相同的，都是行数据记录的**地址**。

所以在非聚簇索引中，**不存在回表**。

### 聚簇索引和非聚簇索引的区别
下图是聚簇索引和非聚簇索引的辅助索引执行过程：
![image](/images/posts/database/mysql/index/secondary-index.png)


# 索引的分类
MySQL 索引的五种类型：
- 主键索引
- 唯一索引
- 普通索引
- 全文索引
- 组合索引

通过给字段添加索引可以提高数据的读取速度，提高项目的**并发能力**和**抗压能力**。

##  主键索引

主键是一种**唯一性索引**，它必须指定为 **PRIMARY KEY**，每个表只能有**一个**主键。

主键往往使用**自动递增**的方式，这样索引**更新**的花费最低（直接插到最右边）。<br>



##  唯一索引
索引列的所有值都只能出现一次，即必须**唯一**，值可以为**空**。

## 普通索引
基本的索引类型，值可以为**空**，没有唯一性的限制。

在使用**聚簇索引**的普通索引时尽量实现**覆盖索引**，提高系统性能。


## 全文索引
搜索全文中的某个关键字。

MyISAM支持，InnoDB 在 5.6 之后支持。

全文索引的索引类型为 FULLTEXT 。

全文索引可以在 varchar ,char ,text 类型的列上创建。

真正的全文索引一般不使用数据库实现。<br>
使用 Lucene，Solr，ElasticSearch 等全文检索引擎实现。

## 组合索引

多列值组成一个索引，专门用于**组合搜索**。


----------


组合索引的**最左匹配原则**

如果使用 (name ,age) 组合索引。<br>
先匹配 name，name符合了再去匹配 age。

----------


**组合索引的顺序非常重要**

加入现在需要建立两个索引： (name ,age) 和 (age) 

如果组合索引的顺序是先 name 再 age<br>
那么还要单独建一个 age 的索引<br>
就需要建立两**棵**索引树

如果组合索引的顺序是先 age 再 name<br>
那么不需要再单独建 age 的索引<br>
就只需要建立一**棵**索引树

----------

现在需要建立三个索引：(name ,age ) ,(name) ,(age)

有两种实现方案：
1. 建立 (name ,age) 和 (name) 两颗索引树
2. 建立 (age,name) 和 (age) 两颗索引树

哪种更好？

**第二种**方案更好。<br>
因为 age 字段是 int 类型，name 字段是字符串类型，age 字段所占据的空间更小。<br>
第一种方案是 name\*2 + age\*1 ，而第二种方案是 name + age\*2。<br>
第二种方案所占据的**空间更小**。


----------




# 存储引擎

|  | InnoDB | MyISAM | Memory |
| :- | :- | :- | :- |
| 索引类型 | 聚簇索引 | 非聚簇索引 | 默认 hash 索引<br>支持 B 树索引 |
| 支持事务 | 是 |  |  |
| 支持表锁 | 是 | 是 | 是 |
| 支持行锁 | 是 |  |  |
| 支持外键 | 是 |  |  |
| 支持自增 | 是 | 是 | 4.1.0后支持 |
| 支持变长列 | 是 | 是 | |
| 支持全文索引 | 5.6后支持 | 是 |  |
| 适合操作类型 | insert<br> delete<br> update | select |
| 文件结构 | .frm 表结构 <br> .idb 数据和索引 | .frm 表结构<br>.myi 索引<br>.myd 数据 | .frm 表结构 |
| 优点 | 支持事务<br>支持回滚<br>有崩溃修复能力<br>多版本并发的事务安全 | 占用空间小<br>处理速度快 | 速度快 |
| 缺点 | 读写效率比较差<br>占用的磁盘空间较大 | 不支持事务的完整性和并发性 | 重启后数据消失 |
| 使用场景 | 高并发<br>更新操作比较多<br>需要使用事务<br>自动灾难恢复 | count 计算很多<br>数据仓库等查询频繁的应用 | 高速的临时数据<br>数据丢失后影响较小 |

## 外键
使用外键可使两个表之间存在依赖关系。<br>
外键所在的表是子表，所依赖的表为父表，父表中被子表关联的字段必须为**主键**或**唯一键**。<br>

当父表中被关联的字段的值被**修改**或**删除**时，子表中对应的字段也会被**修改**或**删除**。<br>
当子表想要**插入**新数据时，其外键列的值必须是父表中**存在**的值。

## 自动增长列
InnoDB 和 MyISAM 都支持 auto_increament 列。


----------


**注意：**<br>
每张表中只能有**一个** auto_increment 列，并且该列要么是**主键**要么是**唯一键**。<br>
也就是说，auto_increament 列**不允许重复值**。

auto_increament 列的值默认从 **1** 开始，**不能为空**。<br>
如果在插入时**省略**了 auto_increament 列或者值为 **0** 或 **null**，那么会**自动**进行递增的操作。<br>
如果插入时声明了 auto_increament 列的值，**合法且不重复**。<br>
1. 该值比当前的值**大**，插入该值，并且**从该值开始递增**。
2. 该值比当前的值**小**，插入该值，**不影响递增**。


----------


在 **InnoDB** 中，为了保证并发下的插入操作不会发生冲突，有一个**自增锁**。<br>
即自增操作是有**锁**来保证的。<br>
如果插入 10 条 sql 数据失败了回滚，但是自增锁依然往后递增了 10 次。<br>

而在 **MyISAM** 中，因为使用的是**表锁**。<br>
不存在并发插入操作，所以不需要自增锁这样的设计。<br>

## InnoDB 的 .idb 文件问题

一般情况下找不到 .idb文件，因为 InnoDB 默认把所有的数据和索引存放在**同一个**文件中

打开 mysql 命令行，输入
```
show variables like 'innodb_file_per_table';
```
结果
```
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | OFF   |
+-----------------------+-------+
```
这个参数的意思是要不要给 InnoDB 中的每一个表建立单独的文件，可以看到是 off ，也就是不。

如果想要单独存放每个表的 .ibd 文件，请如下设置：
```
set global innodb_file_per_table = on;
```

## MyISAM 的存储格式
- **静态型**<br>
	表的所有列都是**静态**的（**定长**的）。<br>
	这种情况下，**维护**和**访问**预定义格式存储的数据需要的开销很**低**。<br>
	但是，需要的**空间**会更多，因为所有数据都占用了该列的**最大空间**。
- **动态型**<br>
	存在**动态**型的列（**不定长**的）。<br>
	- 优点<br>
		使用空间**少**。
	- 缺点<br>
		- 更新数据时，需要**移动**数据，产生**内部碎片**的同时，也**降低**了**维护**和**访问**的**效率**。
		- 解决办法
			- 尽量的使用**定长字段**。
			- 使用 `optimize table` 语句，**整理**表中的碎片。
- **压缩型**<br>
	针对应用程序的声明周期中，**只读**的数据表。<br>
	我们可以通过 **myisampack 工具**转化为压缩表，以**减少**使用的磁盘空间。


## Memory 的表结构
Memory 会将表结构以 .frm 文件的格式存在磁盘中，所以 Memory 的**表结构是持久化的**。<br>
但是 Memory 的数据是存放在内存中，所以重启服务器后**数据将丢失**。

# Mysql 指令
## 查看引擎
- 查看已安装的**所有**引擎
	```
	show engines;
	```
- 查看**某表**的搜索引擎
	```
	show create table 表名;
	```

## 修改引擎
1. 修改配置文件<br>
	打开 `C:\Program Files\MySQL\MySQL Server 5.5` 下的 `my.ini` 文件<br>
	修改其中的 `default-storage-engine` 的值
2. 通过命令行修改配置<br>
	```
	SET @@storage_engine = <Storage Engine>;
	```
3. 使用create table语句指定
	```
	CREATE TABLE t (i INT) ENGINE = <Storage Engine>;
	```
4. 使用 ALTER TABLE 更改存储引擎<br>
	```
	ALTER TABLE t ENGINE = <Storage Engine>;
	```
	


# 索引维护
索引在插入新的值的时候，为了维护索引的有序性，必须要维护。<br>
在维护索引的时候需要需要分以下几种情况：
1. 如果插入一个比较大的值，直接插入即可，几乎没有成本
2. 如果插入的是中间的某一个值，需要逻辑上移动后续的元素，空出位置
3. 如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做页分裂。<br>
	此时性能会受影响同时空间的使用率也会降低。<br>
	除了页分裂之外还包含页合并。

**主键索引尽量使用自增主键**。


# 索引优化
- 索引越**少**越好：
	- 索引是需要持久化存储的，需要占用磁盘空间。
	- 使用时还需要**加载**到内存，占用内存空间。
	- 更新数据时还要**维护**索引。
- 表太**小**不需要建索引，速度反而会变**慢**
	- 没索引<br>
		直接查。
	- 有索引<br>
		先查索引，再查表。
- 主键索引尽量使用**自增**主键<br>
	插入新数据时**维护**索引的成本最低。