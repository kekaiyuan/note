---
layout: post
title: Oracle 之——事务
categories: Oracle
description: Oracle 之——事务
keywords: Oracle，事务
---

Oracle 之——事务

事务共分为：
- 最基本的数据库事务
- 声明式事务
- 分布式事务

其中所有关系型数据库 ( Oracle , MySQL ) 的事务机制都是一样的。

## 事务
事务（Transaction）是一个操作序列。<br>
这些操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位。
- 事务是为了保证数据库的**完整性**
- 事务不能嵌套
- 在 oracle 中，没有事务开始的语句。<br>
	一个 Transaction **起始于**一条 DML ( Insert , Update , Delete ) 语句<br>
	**结束于**以下的几种情况：
	- 用户**显式执行** Commit 语句 提交操作或执行 Rollback语句 回退。
	- 当执行 **DDL** ( Create , Alter , Drop ) 语句事务**自动提交**。
	- 用户正常**断开连接**时， Transaction 自动提交。
	- 系统**崩溃**或**断电**时事务**自动回退**。

增，删，改是数据库的常用操作，在进行操作的时候都需要 **事务** 的保证。<br>
也就是说每次在 PL/SQL 中执行 sql 语句之后都需要完成 commit 的操作。

事务的关键性在于保持**数据一致性**。<br>
如果同一份数据，在同一个时刻只能有一个人访问，就不会出现数据错乱的问题，但是在现在的项目中，更多的是**并发访问**。<br>
并发访问很容易造成数据的**不安全**，即不一致。<br>
如果要保证数据的安全，最主要的方式就是**加锁**的方式，例如 MVCC 。

如果不保证事务的话，会造成**脏读**，**不可重复读**，**幻读**。	

## Oracle 的提交和回滚
Commit 表示事务**成功**地结束。<br>
此时告诉系统，数据库要进入一个新的正确状态，该事务对数据库的所有更新都以交付实施。<br>
每个 Commit 语句都可以看成是一个事务成功的**结束**，同时也是另一个事务的**开始**。

Rollback 表示事务**不成功**的结束。<br>
此时告诉系统，已发生错误，数据库可能处在不正确的状态。<br>
该事务对数据库的更新必须被撤销，数据库应恢复该事务到初始状态。
每个 Rollback 语句同时也是另一个事务的**开始**。

一旦执行了 commit 语句，将目前对数据库的操作提交给数据库（实际写入 DB ），以后就不能用 rollback 进行撤销。

执行一个 DDL ，DCL 语句或从 PL\SQL 正常退出，都会**自动**执行 commit 命令。

### 提交或回滚前数据的状态
- 以前的数据可**恢复**
- **当前**的用户可以看到 DML操作 的结果
- 其他用户**不能**看到 DML操作 的结果
- 被操作的数据被锁住，其他用户不能修改这些数据

### 提交后数据的状态
- 数据的修改被**永久**写在数据库中。 
- 数据以前的状态永久性**丢失**。 
- **所有**的用户都能看到操作后的结果。 
- 记录锁被**释放**，其他用户可操作这些记录。

### 回滚后数据的状态
语句将**放弃**所有的数据修改
- 修改的数据被**回退**。 
- **恢复**数据以前的状态。 
- 行级锁被**释放**。

### savepoint 语句
savepoint 指保存点。

当一个操作集合中包含多条SQL语句，但是只想让其中某部分成功，某部分失败，此时可以使用保存点。

此时如果需要回滚到某一个状态的话使用 rollback to 保存点。

例如<br>
```sql
SQL语句1
SQL语句2
savepoint sp1;
SQL语句3
rollback to sp1;
commit;
```
的结果是
- 语句1 和 语句2 被提交
- 语句3 不会被提交

## 事务的四个特性：ACID
事务有四个特性，ACID 是四个特性的首字母

### 原子性 Atomicity

事务**不可分割**，要么全部提交成功，要么全部失败回滚，不能只执行一部分操作。

一个原子事务要么完整执行，要么干脆不执行。

这意味着，工作单元中的每项任务都必须正确执行。<br>
如果有任一任务执行失败，则整个工作单元或事务就会被终止。<br>
即此前对数据所作的任何修改都将被撤销。

如果所有任务都被成功执行，事务就会被提交，即对数据所作的修改将会是永久性的。

原子性通过 [Undo Log](https://kekaiyuan.github.io//2021/07/10/framework-log/#undo-log) 实现。

### 一致性 Consistency
事务的执行不能破坏数据库数据的**一致性**，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。

一致性代表了底层数据存储的**完整性**。

一致性是四个特性中**最关键**的特性，是**最终的追求**。

它必须由事务系统和应用开发人员共同来保证。
- **事务系统通过保证事务的原子性，隔离性和持久性来满足这一要求。**
- 应用开发人员则需要保证数据库有适当的**约束**(主键，引用完整性等)。<br>
	并且工作单元中所实现的业务逻辑不会导致数据的不一致(即，数据预期所表达的现实业务情况不相一致)。<br>
	- 银行系统中 A 给 B 转账，A 少了 100 元，那么 B 就一定多了 100 元。<br>
		不能出现 A 少了 100 元，但是 B 没有加 100 元的情况。
	- A 给 B 转账 300 元，但是 A 只有 298 元，那么 A 就只能转 298 元。<br>
		不能出现 A 变成 -2 元，而 B 加了 300 元的情况。

### 隔离性 Isolation
事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能不被其他事务干扰。

不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间。<br>
即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。

共有四个隔离级别：
- 读未提交 read uncommitted
- 读已提交 read committed
- 可重复读 repeatable read
- 序列化 serializable
- 隔离级别越高，效率越低。

隔离性通过 [锁](https://kekaiyuan.github.io//2021/07/02/transaction/#%E9%94%81) 来实现

#### 读未提交 read uncommitted
- [x] 脏读<br>
	可以读取其他事务中尚未提交的数据。
- [x] 不可重复读
- [x] 幻读 

#### 读已提交 read committed
只能读取已经提交的数据。
- [ ] 脏读
- [x] 不可重复读<br>
	**一个事务范围内，多次查询某个数据，却得到不同的结果。**<br>
	事务A 读取了某数据后，其他事务**修改**了该数据并**提交**。<br>
	事务A 再次读取该数据读到的是修改后的数据，两次数据不匹配。<br>
	针对 **update** 和 **delete**。
- [x] 幻读 

#### 可重复读 repeatable read
保证事务处理的过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的。
- [ ] 脏读
- [ ] 不可重复读
- [x] 幻读 <br>
	事务 A 在开始时读到 **3** 条记录，然后其他事务**插入**了第 **4** 条数据并**提交**。<br>
	此时事务 A 通过 **select** 语句依然只能读到 **3** 条记录。<br>
	但是如果使用 **insert** , **update** , **delete** 语句就会发现第 **4** 条语句的存在。<br>
	这就是 **幻读**。<br>
	针对 **insert** 。
	- 原因？<br>
		**行锁**只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。
	- 如何解决？<br>
		- 升级锁的级别，但是效率会大大下降，不推荐。
		- 加入**间隙锁**，与行锁配合。<br>
			将两行记录间的空隙加上锁，**阻止新记录的插入**，这个锁称为间隙锁。

#### 序列化 serializable
是最严格的事务隔离级别，它要求所有事务被**串行执行**。<br>
即事务只能一个接一个的进行处理，不能并发执行。
- [ ] 脏读
- [ ] 不可重复读
- [ ] 幻读 


### 持久性 Durability
一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。

即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。

持久性通过 [Redo Log](https://kekaiyuan.github.io//2021/07/10/framework-log/#redo-log) 实现


## 锁
为了解决在并发访问的时候，数据不一致的问题，需要给数据加锁

加锁的同时需要考虑 **粒度** 的问题，即操作对象的单位
- 数据库
- 表
- 行

我可以选择锁住整个**数据库**，锁住整张**表**，或者仅仅锁住我操作的那一**行**数据。

上锁后其他事务无法访问被上锁的数据。

一般情况下，锁的粒度越小，效率越高，粒度越大，效率越低。

在实际的工作环境中，大部分的操作都是**行级锁**  。

